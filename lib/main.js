// Generated by CoffeeScript 1.10.0
(function() {
  var CND, MMX, TOOLS, alert, badge, debug, echo, help, info, log, rpr, urge, use, warn, whisper,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MULTIMIX';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  TOOLS = require('./tools');

  module.exports = MMX = {};

  MMX.mix = function() {
    var R, exclude, i, key, len, mixin, mixins, reducer, reducer_fallback, ref, ref1, target, value;
    mixins = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (!(mixins.length > 0)) {
      return null;
    }
    reducer_fallback = (ref = this.mix.reducers['*']) != null ? ref : 'assign';
    exclude = [];

    /* TAINT support multiple types at all or only PODs? */
    R = CND.isa_list(mixins[0]) ? [] : {};
    for (i = 0, len = mixins.length; i < len; i++) {
      mixin = mixins[i];
      for (key in mixin) {
        value = mixin[key];
        if (indexOf.call(exclude, key) >= 0) {
          continue;
        }
        reducer = (ref1 = this.mix.reducers[key]) != null ? ref1 : reducer_fallback;

        /* TAINT in e.g. mode `append`, should value be skipped if it is `null`? */
        switch (reducer) {
          case 'skip':
            continue;
          case 'assign':
            if (value === void 0) {
              delete R[key];
            } else {
              R[key] = value;
            }
            break;
          case 'append':

            /* TAINT consider to use `Symbol.isConcatSpreadable` in the future */
            target = (R[key] != null ? R[key] : R[key] = []);
            if (CND.isa_list) {
              target.splice.apply(target, [target.length, 0].concat(slice.call(value)));
            } else {
              target.push(value);
            }
            break;
          case 'list':
            (R[key] != null ? R[key] : R[key] = []).push(value);
            break;
          default:
            throw new Error("unknown reducer " + (rpr(reducer)));
        }
      }
    }
    return R;
  };

  use = function() {
    var R, reducers;
    reducers = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /* Returns a version of mix that uses the reducers passed in to `use`; the resulting reducer is
    derived form the reducers list by applying `mix`. Turtles.
     */
    R = {};
    R.mix = MMX.mix.bind(R);
    R.mix.reducers = MMX.mix.apply(MMX, [MMX.reducers].concat(slice.call(reducers)));
    R.mix.tools = MMX.mix.tools;
    return R.mix;
  };

  MMX.mix.use = use.bind(MMX);

  MMX.mix.reducers = {
    '*': 'assign'
  };

  MMX.mix.tools = TOOLS;

}).call(this);

//# sourceMappingURL=main.js.map
