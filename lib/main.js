// Generated by CoffeeScript 1.10.0
(function() {
  var CND, MULTIMIX, alert, badge, debug, echo, help, info, join, log, rpr, urge, warn, whisper, σ_finalize, σ_new_state, σ_reject, σ_unknown_type,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MULTIMIX';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  join = require('path').join;

  σ_new_state = Symbol["for"]('new_state');

  σ_reject = Symbol["for"]('reject');

  σ_finalize = Symbol["for"]('finalize');

  σ_unknown_type = Symbol["for"]('unknown_type');

  warn("introduce json, xjson methods for faster copying of known-to-be-ok values");

  warn("reducer keys: '*' (main), '*/*' (any fields), '**' (main and fields)?");

  MULTIMIX = {};

  MULTIMIX.TOOLS = require('./tools');

  MULTIMIX.REDUCERS = require('./reducers');

  MULTIMIX.COPIERS = require('./copiers');

  MULTIMIX.mix = function(L, mixins, reducers, root, selector) {
    var R, S, copy, description, field_key, field_value, fields, has_fields, hook, i, j, len, len1, mixin, mixin_seed, mixin_tail, mx_key, mx_value, partial_mixin, partial_mixins, reducer, reducers_seed, ref, ref1, ref2, seed, seen, type;
    if (root == null) {
      root = null;
    }
    if (selector == null) {
      selector = [];
    }
    if (mixins.length === 0) {
      return null;
    }
    mixin_seed = mixins[0], mixin_tail = 2 <= mixins.length ? slice.call(mixins, 1) : [];
    reducers_seed = reducers != null ? reducers['seed'] : void 0;
    seed = reducers_seed != null ? reducers_seed : mixin_seed;

    /* TAINT consider to call with `S` instead for consistency */
    if (CND.isa_function(seed)) {
      seed = seed(mixins);
    }
    type = CND.type_of(seed);
    description = (ref = L.type_descriptions[type]) != null ? ref : L.type_descriptions[σ_unknown_type];
    has_fields = description.has_fields, copy = description.copy;
    seen = new Map();
    R = seed;

    /* TAINT cant return here b/c of `after` hook */
    if ((!has_fields) && (mixin_tail.length === 0)) {
      return R;
    }
    S = L.REDUCERS[σ_new_state](reducers, seen);
    if (root == null) {
      root = R;
    }

    /* Deal with nested reducers first: */
    if ((fields = S.reducers['fields']) != null) {
      for (field_key in fields) {
        field_value = fields[field_key];
        if (CND.isa_pod(field_value)) {
          selector.push(field_key);
          partial_mixins = [];
          for (i = 0, len = mixins.length; i < len; i++) {
            mixin = mixins[i];
            partial_mixin = mixin[field_key];
            if (partial_mixin != null) {
              partial_mixins.push(partial_mixin);
            }
          }
          if (partial_mixins.length > 0) {
            R[field_key] = MULTIMIX.mix(L, partial_mixins, field_value, root, selector);
          }
          reducers[field_key] = 'skip';
          selector.pop(field_key);
        }
      }
    }

    /* Process unnested reducers: */
    for (j = 0, len1 = mixins.length; j < len1; j++) {
      mixin = mixins[j];
      for (mx_key in mixin) {
        mx_value = mixin[mx_key];
        S.path = join.apply(null, slice.call(selector).concat([mx_key]));
        S.root = root;
        S.current = R;
        S.reducer_name = (ref1 = (ref2 = S.reducers['fields']) != null ? ref2[mx_key] : void 0) != null ? ref1 : S.reducer_fallback;
        if (L.REDUCERS[σ_reject](S, mx_key, mx_value)) {
          continue;
        }
        if ((reducer = L.REDUCERS[S.reducer_name]) == null) {
          throw new Error("unknown reducer " + (rpr(S.reducer_name)));
        }
        reducer.call(L.REDUCERS, S, mx_key, mx_value);
      }
    }
    L.REDUCERS[σ_finalize](S);
    if ((hook = reducers != null ? reducers['after'] : void 0) != null) {
      if ((CND.type_of(hook)) !== 'function') {
        throw new Error("expected function for 'after' hook, got a " + type);
      }
      hook(S);
    }
    return R;
  };


  /*
    '[object Object]': copyObject,
    '[object Array]': copyArray,
    '[object Error]': justDont,
    '[object Map]': copyMap,
    '[object Set]': copySet,
  
    '[object Promise]': justDont,
    '[object XMLHttpRequest]': justDont,
    '[object NodeList]': copyArray,
    '[object ArrayBuffer]': copySlice,
    '[object Int8Array]': copyConstructor,
    '[object Uint8Array]': copyConstructor,
    '[object Uint8ClampedArray]': copyConstructor,
    '[object Int16Array]': copyConstructor,
    '[object Uint16Array]': copyConstructor,
    '[object Int32Array]': copyConstructor,
    '[object Uint32Array]': copyConstructor,
    '[object Float32Array]': copyConstructor,
    '[object Float64Array]': copyConstructor
   */

  (function() {
    var copy_by_constructor, copy_id, copy_list, copy_map, copy_object, copy_set, dont_copy;
    copy_id = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = MULTIMIX.COPIERS).id.apply(ref, P);
    };
    copy_object = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = MULTIMIX.COPIERS).object.apply(ref, P);
    };
    copy_list = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = MULTIMIX.COPIERS).list.apply(ref, P);
    };
    copy_map = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = MULTIMIX.COPIERS).map.apply(ref, P);
    };
    copy_set = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = MULTIMIX.COPIERS).set.apply(ref, P);
    };
    copy_by_constructor = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = MULTIMIX.COPIERS).by_constructor.apply(ref, P);
    };
    dont_copy = function() {
      var P, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = MULTIMIX.COPIERS).dont.apply(ref, P);
    };
    return MULTIMIX.type_descriptions = {
      boolean: {
        type: 'boolean',
        has_fields: false,
        copy: copy_id
      },
      "null": {
        type: 'null',
        has_fields: false,
        copy: copy_id
      },
      text: {
        type: 'text',
        has_fields: false,
        copy: copy_id
      },
      undefined: {
        type: 'undefined',
        has_fields: false,
        copy: copy_id
      },
      infinity: {
        type: 'infinity',
        has_fields: false,
        copy: copy_id
      },
      number: {
        type: 'number',
        has_fields: false,
        copy: copy_id
      },
      nan: {
        type: 'nan',
        has_fields: false,
        copy: copy_id
      },
      pod: {
        type: 'pod',
        has_fields: true,
        copy: copy_object
      },
      list: {
        type: 'list',
        has_fields: true,
        copy: copy_list
      },
      map: {
        type: 'map',
        has_fields: true,
        copy: copy_map
      },
      set: {
        type: 'set',
        has_fields: true,
        copy: copy_set
      },
      date: {
        type: 'date',
        has_fields: true,
        copy: copy_by_constructor
      },
      regex: {
        type: 'regex',
        has_fields: true,
        copy: copy_by_constructor
      },
      buffer: {
        type: 'buffer',
        has_fields: true,
        copy: dont_copy
      },
      arraybuffer: {
        type: 'arraybuffer',
        has_fields: true,
        copy: dont_copy
      },
      error: {
        type: 'error',
        has_fields: true,
        copy: dont_copy
      },
      "function": {
        type: 'function',
        has_fields: true,
        copy: dont_copy
      },
      symbol: {
        type: 'symbol',
        has_fields: false,
        copy: dont_copy
      },
      weakmap: {
        type: 'weakmap',
        has_fields: false,
        copy: dont_copy
      },
      generator: {
        type: 'generator',
        has_fields: false,
        copy: dont_copy
      },
      "arguments": {
        type: 'arguments',
        has_fields: false,
        copy: dont_copy
      },
      global: {
        type: 'global',
        has_fields: false,
        copy: dont_copy
      }
    };
  })();

  MULTIMIX.type_descriptions[σ_unknown_type] = {
    type: σ_unknown_type,
    has_fields: false,
    copy: MULTIMIX.COPIERS.dont
  };

  MULTIMIX.use = function() {
    var R, custom_reducers, reducers;
    custom_reducers = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /* Returns a version of `mix` that uses the reducers passed in to `use`; the resulting reducer is
    derived from the reducers list by applying `mix`. Turtles.
     */
    custom_reducers.splice(0, 0, {
      '*': 'assign'
    });
    reducers = MULTIMIX.mix(MULTIMIX, custom_reducers, null);
    debug('28773', custom_reducers);
    urge('28773', reducers);
    R = function() {
      var mixins;
      mixins = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return MULTIMIX.mix(R, mixins, reducers);
    };
    R.TOOLS = MULTIMIX.TOOLS;
    R.REDUCERS = MULTIMIX.REDUCERS;
    R.COPIERS = MULTIMIX.COPIERS;
    R.type_descriptions = MULTIMIX.type_descriptions;
    R.use = MULTIMIX.use;
    return R;
  };

  module.exports = {
    mix: MULTIMIX.use()
  };

}).call(this);

//# sourceMappingURL=main.js.map
