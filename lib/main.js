// Generated by CoffeeScript 1.10.0
(function() {
  var CND, MULTIMIX, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MULTIMIX';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  MULTIMIX = {};

  MULTIMIX.TOOLS = require('./tools');

  MULTIMIX.REDUCERS = require('./reducers');

  MULTIMIX.mix = function(me, reducers, mixins) {
    var R, S, base, count, i, key, len, mixin, reducer, ref, ref1, ref2, ref3, ref4, ref5, ref6, sum, target, value, values;
    if (!(mixins.length > 0)) {
      return null;
    }

    /* TAINT support multiple types at all or only PODs? */
    R = CND.isa_list(mixins[0]) ? [] : {};
    S = {};

    /* TAINT presently the reducers namespace has mixin keys as keys except for the special
    key '*'. This severly restricts the expressiveness of the configuration. Solutions:
    * move mixin keys to a segregated object
    * use sigils like '~' or syntax like '<type>' for special keys
    * reserve one other special key for all special keys
     */
    S.reducers = reducers != null ? reducers : {};
    S.reducer_fallback = (ref = S.reducers['*']) != null ? ref : 'assign';
    S.cache = {};
    S.averages = {};
    S.tag_keys = (function() {
      var ref1, results;
      ref1 = S.reducers;
      results = [];
      for (key in ref1) {
        value = ref1[key];
        if (value === 'tag') {
          results.push(key);
        }
      }
      return results;
    })();
    S.skip = [];
    S.functions = {};
    ref1 = S.reducers;
    for (key in ref1) {
      reducer = ref1[key];
      if (reducer === 'include') {
        S.reducers[key] = S.reducer_fallback;
        continue;
      }
      if (CND.isa_function(reducer)) {
        S.functions[key] = reducer;
        S.reducers[key] = 'function';
      }
    }
    for (i = 0, len = mixins.length; i < len; i++) {
      mixin = mixins[i];
      for (key in mixin) {
        value = mixin[key];
        if ((indexOf.call(S.skip, key) >= 0) || (value === void 0 && reducer !== 'assign')) {
          continue;
        }
        reducer = (ref2 = S.reducers[key]) != null ? ref2 : S.reducer_fallback;

        /* TAINT in e.g. mode `append`, should value be skipped if it is `null`? */
        switch (reducer) {
          case 'skip':
            continue;
          case 'assign':
            if (value === void 0) {
              delete R[key];
            } else {
              R[key] = value;
            }
            break;
          case 'merge':
            me.REDUCERS.merge(S, R, key, value);
            break;
          case 'append':

            /* TAINT consider to use `Symbol.isConcatSpreadable` in the future */
            target = (R[key] != null ? R[key] : R[key] = []);
            if (CND.isa_list) {
              target.splice.apply(target, [target.length, 0].concat(slice.call(value)));
            } else {
              target.push(value);
            }
            break;
          case 'list':
            (R[key] != null ? R[key] : R[key] = []).push(value);
            break;
          case 'add':
            R[key] = ((ref3 = R[key]) != null ? ref3 : 0) + value;
            break;
          case 'tag':
            me.tools.meld((target = R[key] != null ? R[key] : R[key] = []), value);
            break;
          case 'function':
            ((base = S.cache)[key] != null ? base[key] : base[key] = []).push(value);
            break;
          default:
            throw new Error("unknown reducer " + (rpr(reducer)));
        }
      }
    }

    /* tags */
    for (key in R) {
      value = R[key];
      if (indexOf.call(S.tag_keys, key) < 0) {
        continue;
      }
      R[key] = reduce_tag(R[key]);
    }

    /* averages */
    ref4 = S.averages;
    for (key in ref4) {
      ref5 = ref4[key], sum = ref5[0], count = ref5[1];
      R[key] = sum / count;
    }

    /* functions */
    ref6 = S.cache;
    for (key in ref6) {
      values = ref6[key];
      R[key] = S.functions[key](values, R);
    }
    return R;
  };

  MULTIMIX.use = function() {
    var R, custom_reducers, reducers;
    custom_reducers = 1 <= arguments.length ? slice.call(arguments, 0) : [];

    /* Returns a version of mix that uses the reducers passed in to `use`; the resulting reducer is
    derived form the reducers list by applying `mix`. Turtles.
     */
    custom_reducers.splice(0, 0, {
      '*': 'assign'
    });
    reducers = MULTIMIX.mix(MULTIMIX, null, custom_reducers);
    R = function() {
      var mixins;
      mixins = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return MULTIMIX.mix(R, reducers, mixins);
    };
    R.TOOLS = MULTIMIX.TOOLS;
    R.REDUCERS = MULTIMIX.REDUCERS;
    R.use = MULTIMIX.use;
    return R;
  };

  module.exports = {
    mix: MULTIMIX.use()
  };

}).call(this);

//# sourceMappingURL=main.js.map
