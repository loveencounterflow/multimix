{
  "version": 3,
  "file": "proxy-instead-of-prototype.js",
  "sourceRoot": "../..",
  "sources": [
    "src/experiments/proxy-instead-of-prototype.coffee"
  ],
  "names": [],
  "mappings": ";AAAA;EAAA;;;;;;;AAAA,MAAA,GAAA,EAAA,CAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,QAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA,EAAA,CAAA;;;EAWA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAE5B,CAAA,GAAI,QAAA,CAAE,CAAF,CAAA;WAAS,CAAA,WAAA,CAAA,CAAc,IAAC,CAAA,IAAf,EAAA,CAAA,CAAuB,CAAvB,CAAA;EAAT;;EACJ,IAAA,GAAO;IAAE,IAAA,EAAM;EAAR,EAtBP;;;;EAyBA,CAAA,GAAI,MAAM,CAAC,MAAP,CAAc,CAAd,EAAiB;IAAE,IAAA,EAAM;MAAE,KAAA,EAAO;IAAT;EAAR,CAAjB;;EAEJ,QAAA,GACE;IAAA,GAAA,EAAK,QAAA,CAAE,MAAF,EAAU,QAAV,CAAA;MACH,KAAA,CAAM,SAAN,EAAiB,GAAA,CAAI,MAAJ,CAAjB;MACA,KAAA,CAAM,SAAN,EAAiB,GAAA,CAAI,QAAJ,CAAjB;MACO,IAAG,QAAA,IAAY,MAAf;eAA2B,MAAQ,CAAA,QAAA,EAAnC;OAAA,MAAA;eAAmD,QAAnD;;IAHJ;EAAL;;EAKF,KAAA,GAAQ,IAAI,KAAJ,CAAU,CAAV,EAAa,QAAb,EAjCR;;;;;;;;;;EA4CA,CAAA,GAAI,QAAA,CAAA,CAAA;IACF,IAAC,CAAA,IAAD,GAAQ;AACR,WAAO,CAAE,QAAA,CAAA,CAAA;aAAG,GAAA,GAAM,IAAC,CAAA,IAAP,GAAc;IAAjB,CAAF,CAAwB,CAAC,IAAzB,CAA8B,IAA9B;EAFL;;EAIJ,IAAA,GAAO;IAAE,IAAA,EAAM,MAAR;IAAgB,GAAA,EAAK,GAArB;IAA0B,CAAA,EAAG,QAAA,CAAA,CAAA;aAAG,CAAA,WAAA,CAAA,CAAc,IAAC,CAAA,IAAf,CAAoB,YAApB,CAAA,CAAkC,IAAC,CAAA,GAAnC,CAAA;IAAH;EAA7B;;EACP,KAAA,GAAQ,QAAA,CAAA,CAAA;AACN,QAAA;IAAA,CAAA,GAAI,CAAE,QAAA,CAAA,CAAA;aAAG,GAAA,GAAM,IAAC,CAAA,IAAP,GAAc;IAAjB,CAAF,CAAwB,CAAC,IAAzB,CAA8B,IAA9B,EAAJ;;IAEA,MAAM,CAAC,cAAP,CAAsB,CAAtB,EAAyB,IAAzB;AACA,WAAO;EAJD,EAjDR;;;EAyDA,CAAA,GAAI,KAAA,CAAA;;EACJ,OAAA,CAAQ,CAAR;;EACA,OAAA;;AAAe;IAAA,KAAA,SAAA;mBAAL;IAAK,CAAA;;MAAf;;EACA,OAAA,CAAQ,CAAA,CAAA,CAAR;;EACA,OAAA,CAAQ,CAAC,CAAC,CAAF,CAAA,CAAR;;EAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3KA",
  "sourcesContent": [
    "\n###\nGreat discussion:\nhttps://gist.github.com/jeremyckahn/5552373\n\nMust read:\nhttps://davidwalsh.name/javascript-objects-distractions\n###\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'KBM/APP'\ndebug                     = CND.get_logger 'debug',     badge\nalert                     = CND.get_logger 'alert',     badge\nwhisper                   = CND.get_logger 'whisper',   badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\n\nx = ( x ) -> \"helo world #{@name} #{x}\"\nbase = { name: 'my name', }\n# x.__proto__ = base\n# Object.setPrototypeOf x, base\nx = Object.create x, { name: { value: 'me', }, }\n\nsettings =\n  get: ( target, property ) ->\n    debug '11101-1', rpr target\n    debug '11101-2', rpr property\n    return if property of target then target[ property ] else '!!!!!'\n\nproxy = new Proxy x, settings\n\n# help x 42\n# help x.foo\n# help proxy 42\n# help proxy.foo\n\n# debug ->\n# debug new -> ( -> )\n# debug ( new -> ( -> ) ) 42\n\nX = ->\n  @name = 'didi'\n  return ( -> '*' + @name + '*' ).bind @\n\nbase = { name: 'lulu', age: 108, f: -> \"my name is #{@name}, my age is #{@age}\" }\nnew_x = ->\n  R = ( -> '*' + @name + '*' ).bind base\n  # R.__proto__ = base\n  Object.setPrototypeOf R, base\n  return R\n\n\n# x = new X()\nx = new_x()\nwhisper x\nwhisper ( name for name of x )\nwhisper x()\nwhisper x.f()\n\n\n\n###\nhttps://stackoverflow.com/a/31236132/7568091\n###\n\n```\nfunction getDesc (obj, prop) {\n  var desc = Object.getOwnPropertyDescriptor(obj, prop);\n  return desc || (obj=Object.getPrototypeOf(obj) ? getDesc(obj, prop) : void 0);\n}\nfunction multiInherit (...protos) {\n  return Object.create(new Proxy(Object.create(null), {\n    has: (target, prop) => protos.some(obj => prop in obj),\n    get (target, prop, receiver) {\n      var obj = protos.find(obj => prop in obj);\n      return obj ? Reflect.get(obj, prop, receiver) : void 0;\n    },\n    set (target, prop, value, receiver) {\n      var obj = protos.find(obj => prop in obj);\n      return Reflect.set(obj || Object.create(null), prop, value, receiver);\n    },\n    *enumerate (target) { yield* this.ownKeys(target); },\n    ownKeys(target) {\n      var hash = Object.create(null);\n      for(var obj of protos) for(var p in obj) if(!hash[p]) hash[p] = true;\n      return Object.getOwnPropertyNames(hash);\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      var obj = protos.find(obj => prop in obj);\n      var desc = obj ? getDesc(obj, prop) : void 0;\n      if(desc) desc.configurable = true;\n      return desc;\n    },\n    preventExtensions: (target) => false,\n    defineProperty: (target, prop, desc) => false,\n  }));\n}\n```\n\n###\n\nExplanation\n\nA proxy object consists of a target object and some traps, which define custom behavior for fundamental\noperations.\n\nWhen creating an object which inherits from another one, we use Object.create(obj). But in this case we want\nmultiple inheritance, so instead of obj I use a proxy that will redirect fundamental operations to the\nappropriate object.\n\nI use these traps:\n\n* The has trap is a trap for the in operator. I use some to check if at least one prototype contains the\n  property.\n\n* The get trap is a trap for getting property values. I use find to find the first prototype which contains\n  that property, and I return the value, or call the getter on the appropriate receiver. This is handled by\n  Reflect.get. If no prototype contains the property, I return undefined.\n\n* The set trap is a trap for setting property values. I use find to find the first prototype which contains\n  that property, and I call its setter on the appropriate receiver. If there is no setter or no prototype\n  contains the property, the value is defined on the appropriate receiver. This is handled by Reflect.set.\n\n* The enumerate trap is a trap for for...in loops. I iterate the enumerable properties from the first\n  prototype, then from the second, and so on. Once a property has been iterated, I store it in a hash table\n  to avoid iterating it again. Warning: This trap has been removed in ES7 draft and is deprecated in\n  browsers.\n\n* The ownKeys trap is a trap for Object.getOwnPropertyNames(). Since ES7, for...in loops keep calling\n  [[GetPrototypeOf]] and getting the own properties of each one. So in order to make it iterate the\n  properties of all prototypes, I use this trap to make all enumerable inherited properties appear like own\n  properties.\n\n* The getOwnPropertyDescriptor trap is a trap for Object.getOwnPropertyDescriptor(). Making all enumerable\n  properties appear like own properties in the ownKeys trap is not enough, for...in loops will get the\n  descriptor to check if they are enumerable. So I use find to find the first prototype which contains that\n  property, and I iterate its prototypical chain until I find the property owner, and I return its\n  descriptor. If no prototype contains the property, I return undefined. The descriptor is modified to make\n  it configurable, otherwise we could break some proxy invariants.\n\n* The preventExtensions and defineProperty traps are only included to prevent these operations from\n  modifying the proxy target. Otherwise we could end up breaking some proxy invariants.\n\nThere are more traps available, which I don't use\n\n* The getPrototypeOf trap could be added, but there is no proper way to return the multiple prototypes. This\n  implies instanceof won't work neither. Therefore, I let it get the prototype of the target, which\n  initially is null.\n\n* The setPrototypeOf trap could be added and accept an array of objects, which would replace the prototypes.\n  This is left as an exercice for the reader. Here I just let it modify the prototype of the target, which\n  is not much useful because no trap uses the target.\n\n* The deleteProperty trap is a trap for deleting own properties. The proxy represents the inheritance, so\n  this wouldn't make much sense. I let it attempt the deletion on the target, which should have no property\n  anyway.\n\n* The isExtensible trap is a trap for getting the extensibility. Not much useful, given that an invariant\n  forces it to return the same extensibility as the target. So I just let it redirect the operation to the\n  target, which will be extensible.\n\n* The apply and construct traps are traps for calling or instantiating. They are only useful when the target\n  is a function or a constructor.\n\nExample\n###\n\n```\n// Creating objects\nvar o1, o2, o3,\n    obj = multiInherit(o1={a:1}, o2={b:2}, o3={a:3, b:3});\n\n// Checking property existences\n'a' in obj; // true   (inherited from o1)\n'b' in obj; // true   (inherited from o2)\n'c' in obj; // false  (not found)\n\n// Setting properties\nobj.c = 3;\n\n// Reading properties\nobj.a; // 1           (inherited from o1)\nobj.b; // 2           (inherited from o2)\nobj.c; // 3           (own property)\nobj.d; // undefined   (not found)\n\n// The inheritance is \"live\"\nobj.a; // 1           (inherited from o1)\ndelete o1.a;\nobj.a; // 3           (inherited from o3)\n\n// Property enumeration\nfor(var p in obj) p; // \"c\", \"b\", \"a\"\n```\n\n\n\n\n\n\n"
  ]
}