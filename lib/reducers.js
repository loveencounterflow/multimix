// Generated by CoffeeScript 1.10.0
(function() {
  var CND, TOOLS, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper, σ_finalize, σ_new_state, σ_reject,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MULTIMIX/REDUCERS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  TOOLS = require('./tools');

  σ_new_state = Symbol["for"]('new_state');

  σ_reject = Symbol["for"]('reject');

  σ_finalize = Symbol["for"]('finalize');

  this[σ_new_state] = function(reducers) {
    var S, key, reducer, ref, ref1, value;
    S = {};
    S.reducers = reducers != null ? reducers : {};
    S.reducer_fallback = (ref = S.reducers['*']) != null ? ref : 'assign';
    S.cache = {};
    S.averages = {};
    S.tag_keys = (function() {
      var ref1, results;
      ref1 = S.reducers;
      results = [];
      for (key in ref1) {
        value = ref1[key];
        if (value === 'tag') {
          results.push(key);
        }
      }
      return results;
    })();
    S.skip = [];
    S.functions = {};
    S.path = null;
    S.root = null;
    S.current = null;

    /* TAINT presently the reducers namespace has mixin keys as keys except for the special
    key '*'. This severly restricts the expressiveness of the configuration. Solutions:
    * move mixin keys to a segregated object
    * use sigils like '~' or syntax like '<type>' for special keys
    * reserve one other special key for all special keys
     */
    ref1 = S.reducers;
    for (key in ref1) {
      reducer = ref1[key];
      if (reducer === 'include') {
        S.reducers[key] = S.reducer_fallback;
        continue;
      }
      if (CND.isa_function(reducer)) {
        S.functions[key] = reducer;
        S.reducers[key] = 'function';
      }
    }
    return S;
  };

  this[σ_finalize] = function(S) {

    /* tags */
    var count, key, ref, ref1, ref2, ref3, sum, value, values;
    ref = S.current;
    for (key in ref) {
      value = ref[key];
      if (indexOf.call(S.tag_keys, key) < 0) {
        continue;
      }
      S.current[key] = TOOLS.reduce_tag(S.current[key]);
    }

    /* averages */
    ref1 = S.averages;
    for (key in ref1) {
      ref2 = ref1[key], sum = ref2[0], count = ref2[1];
      S.current[key] = sum / count;
    }

    /* functions */
    ref3 = S.cache;
    for (key in ref3) {
      values = ref3[key];
      S.current[key] = S.functions[key](values, S);
    }
    return null;
  };

  this[σ_reject] = function(S, key, value) {
    return (indexOf.call(S.skip, key) >= 0) || (value === void 0 && S.reducer_name !== 'assign');
  };

  this.assign = function(S, R, key, value) {
    if (value === void 0) {
      delete R[key];
    } else {
      R[key] = value;
    }
    return null;
  };

  this.skip = function(S, R, key, value) {
    return null;
  };

  this.merge = function(S, R, key, value) {
    var sub_key, sub_value, target;
    if (!CND.isa_pod(value)) {
      throw new Error("expected a POD, got a " + (CND.type_of(value)));
    }
    target = (R[key] != null ? R[key] : R[key] = {});
    for (sub_key in value) {
      sub_value = value[sub_key];
      target[sub_key] = sub_value;
    }
    return null;
  };

  this.append = function(S, R, key, value) {

    /* TAINT consider to use `Symbol.isConcatSpreadable` in the future */
    var target;
    target = (R[key] != null ? R[key] : R[key] = []);
    if (CND.isa_list) {
      target.splice.apply(target, [target.length, 0].concat(slice.call(value)));
    } else {
      target.push(value);
    }
    return null;
  };

  this.list = function(S, R, key, value) {
    (R[key] != null ? R[key] : R[key] = []).push(value);
    return null;
  };

  this.add = function(S, R, key, value) {
    var ref;
    R[key] = ((ref = R[key]) != null ? ref : 0) + value;
    return null;
  };

  this.average = function(S, R, key, value) {
    var base, target;
    target = (base = S.averages)[key] != null ? base[key] : base[key] = [0, 0];
    target[0] = target[0] + value;
    target[1] = target[1] + 1;
    return null;
  };

  this.tag = function(S, R, key, value) {
    var target;
    TOOLS.meld((target = R[key] != null ? R[key] : R[key] = []), value);
    return null;
  };

  this["function"] = function(S, R, key, value) {

    /* Cache current value for later processing by `σ_finalize`: */
    var base;
    ((base = S.cache)[key] != null ? base[key] : base[key] = []).push(value);
    return null;
  };

}).call(this);

//# sourceMappingURL=reducers.js.map
